# [第７回日本情報オリンピック 予選（オンライン）](https://atcoder.jp/contests/joi2008yo/tasks)

## 備考

- 特になし

## [D](https://atcoder.jp/contests/joi2008yo/tasks/joi2008yo_d)

- 2020/05/10 解答
- 考え方:
  - n個の星の座標をズラすと必ず特定のズラし方によってm個の星の座標と一致する箇所が現れる
    - なのでm個の星の座標の内のどれか1つに固定する形でn個の星の座標をズラす
  - n個の星の座標を見て、中にm個の星の座標が全てあるならズラした分の座標を取得すれば良い
    - ただし本来はm個の星に関してをズラした分の数字が欲しいため、このまま出力すると符号が逆になってしまう, -1をかけたものが真に求めている座標となる
- 実装:
  - m個の星の座標を(x,y)の形のタプルにして内包表記で取得(mxy)
    - 後で座標が一致しているか確認するためにsmxy = set(mxy)としておく
  - n個の星の座標はnumpy形式で扱いたいので(x,y)の形のリストを内包表記で取得(nxy)
    - lambda式を使い各座標のxのみの座標リスト, yのみの座標リストを作成(nx, ny)
    - nx,nyはnp.array形式にしておく
  - 0~mの範囲でiを回し以下を繰り返す
    - mxy[i]よりx1, y1を取得(mxy[i]を基準とする星にする)
    - 0~nの範囲でjを回しnxy[j]よりx2, y2を取得
      - x-x2,y-y2をして座標間の距離xx, yyを取得
      - nxにxxを, nyにyyを加算しn個の星全ての座標をズラす
      - nx,nyをzipでまとめn個の座標(x,y)のタプル形状にする(ab)
      - len(smxy&set(ab))で座標の一致してる個数を数える
        - m個丁度であればxxとyyの座標それぞれに-1かけたものを出力して終了
        - 異なる場合ズラした分の座標xx, yyをnx, nyから差し引いて元の数字に戻す

## [E](https://atcoder.jp/contests/joi2008yo/tasks/joi2008yo_e)

- 2020/05/19 解答(自力じゃない)
- 考え方:
  - 1, 0 で構成された行列について以下のことを1回行う
    - 好きなだけ行を選んでその行の1,0を反転 → 好きなだけ列を選んでその列の1,0を反転
  - 最も0が多くなるパターンを調べ、0の個数を解答する
  - 行列(r, c)の内rは最大10と小さいのでbit全探索が使える
    - 行を選択してひっくり返すパターンを2^rのbitで表す
  - 各パターン毎に以下を見る
    - ひっくり返した後に各列を見ると0がtt個, 1がr-tt個存在する
      - この内大きい方を選択する = その列をひっくり返すかどうかの判断になる
    - 各列のmax(tt, r-tt)の合計tとansを比較して最大値を更新する
    - 次のパターンについて調べる
  - 最後にansを出力すれば良い
- 実装:
  - r, c, Aを入力より取得
  - ansを初期化(=0)
  - 2**rのbit全探索
    - 各パターンでの行列全体の出荷可能枚数をtとして初期化
    - 行を見たいのでc回ループ
      - 各列での出荷可能枚数をttとして初期化
      - r行分ループ
        - kのフラグが立っていて尚且A[k][j]番目が1ならttに1加算
        - フラグが立っておらずA[k][j]番目が0ならttに1加算
      - max(tt, r-tt)が各列の出荷可能枚数なのでこれをtに加算
    - ans = max(ans, t)でansを更新
  - print(ans)で終わり
- 備考: PyPyじゃないと間に合わない
