# [ABC128](https://atcoder.jp/contests/abc128/tasks)

## 備考

- A, Bは回答済み

## [C](https://atcoder.jp/contests/abc128/tasks/abc128_c)

- 2020/05/11 解答(自力じゃない)
- bit全探索を使う問題(苦手っぽいのでしっかり記載する)
- 調べたいのは全部の電球が点灯するスイッチの押し方
- 考え方:
  - n個のスイッチのon, offの2状態の組み合わせはn^2パターン存在する
  - その全ての組合わせの中で全部の電球が点灯してるかを調べる
    - 1つのon, offの組み合わせを試した際に、各電球を見て点灯の有無を確認するということ
  - on, offの組み合わせiの中で、k番目のスイッチがonになっており、尚且電球jにそのスイッチが接続されてる場合、onになっているスイッチの個数を記録するcntに1加算
    - on,offの組み合わせとk番目のスイッチがonになっているかをbitで調べる
    - cntを2で割った余りがpjと一致すれば次の電球についても同様に確認
    - 不一致ならi+1番目の組み合わせを試す
  - 不一致な箇所が出ない場合、組み合わせi = 全ての電球が点灯するということになるのでカウントansを1増やす
    - 最後にansを出力すればおーけー
- 実装
  - 入力の取得, 答えansの宣言
    - A内の各配列の0番目はいくつのスイッチがi番目の電球に繋がっているかを示すがここでは不要なので除外し、配列内の数字を後のループの数字に合わせたいので1引いておく

```ABC128_C.py
n, m = map(int, input().split())
A = [list(map(lambda x: int(x)-1, input().split()))[1:] for _ in range(m)]
p = list(map(int, input().split()))
ans = 0
```
  
  - 2**n通りのスイッチについて確かめ、その中でm個の電球についてを見る
    - スイッチを押した個数をカウントしておく変数cntを宣言
    - 組み合わせiの内スイッチkの箇所がonになっているかを(i>>k) & 1で調べている
    - 上記がTrueで尚且スイッチkが電球A[j]に接続されている場合cntを+1
    - その電球についてを確かめた後cntの偶機がp[j]と一致するかを調べる
      - 一致していれば次の電球
      - 不一致な場合、組み合わせをi+1番目の組み合わせを調べる
    - 全てが一致している場合ansを1加算
  - 最後にansを出力

```ABC128_C.py
  for i in range(1<<n):
    for j in range(m):
        cnt = 0
        for k in range(n):
            if ((i>>k) & 1) and k in A[j]: cnt += 1
        if cnt%2!=p[j]: break
    else: ans += 1
  print(ans)
```
