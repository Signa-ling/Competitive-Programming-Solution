# [AGC039](https://atcoder.jp/contests/agc039/tasks)

## 備考

- 特になし

## [A](https://atcoder.jp/contests/agc039/tasks/agc039_a)

- 2020/04/26 解答(自力じゃない)
- 考え方:
  - 文字列Sを基に必要操作回数の最小値を求める
  - もしSが全部同じ文字で構成されていた場合, len(S)*k//2回が答えになる
    - ex) aaaaa, 2 -> ababababab -> 5*2//2=5回
  - そうでない場合,置き換えた回数T*kが最大回数になる
    - ここでもしSの先頭と末尾が同じ文字なら先頭/末尾に続く同じ文字の個数a, bを求める
    - a,bを利用して最大回数T*kから((a//2 + b//2 + (a-b//2)) * (k-1))を引いた回数が答えになる
- 実装:
  - まず与えられた文字列Sが全部同一かを判定するためにset(S)の個数が1になるかを調べる
    - 1ならans = len(S)*k//2として最後の行へ
  - ならない場合Tを調べる
  - ついでに一致不一致に関係なくa,bの個数を調べておいたほうが手間が無いのでこれもやる
    - 関数cal(引数は文字列S)を用意
    - calの中で仮文字列tmp=S[0], a,bの回数であるab=1, 置換回数cnt=0, 先頭からの文字が同じかを判定するflag=Trueを用意し, S[1:]の範囲で文字sについて次の3つを調べる
      - S[0]とsが不一致ならflagをFalseにする
      - flag==Trueであればabを1加算
      - 仮文字列tmpの末尾とsが同じ文字ならsを置換文字(ここでは'*')に変え, cntに1加算
    - tmpの末尾にsを加えループが終わるまで上の3判定とsの追加を繰り返す
    - abとcntを返す
    - Sと反転したS=S'に対してcalの操作を行う
      - 元の文字列でaを, 逆文字列を使うことでbを求める
    - cntの回数はどちらか1回分求められれば良い(2回求めるけど結局どっちのcntも同じ値になるので)
    - cnt*k=ansとしS[0]==S[-1]なら上記のa,bを用いた計算を行いそれをansとする
  - 最後にansを出力して終わり
